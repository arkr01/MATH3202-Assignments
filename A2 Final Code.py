from gurobipy import *
from math import *
import pandas as pd

# Sets/Data

# Use pandas to import the csv files as data frames
nodes = pd.read_csv('nodes2.csv')
arcs = pd.read_csv('grid.csv')

# Arc Numbers
A = arcs['Arc']

# Node Numbers
N = nodes['Node']

# Comm 1 - Main generator costs [change for your data]
cost = {
    20: 62,
    19: 75,
    40: 78,
    2: 77
}

# Comm 1 - Main generator capacities [change for your data]
c = {
    20: 377,
    19: 754,
    40: 745,
    2: 580
}

# Comm 1 - Original generator node numbers (i.e. excluding the gas generator) - order of generator
# numbers is unimportant [change for your data]
mainGenerators = [20, 19, 40, 2]

# Comm 2 - Transmission powerLoss
powerLoss = 0.001

# Comm 2 - Calculate arc lengths (Euclidean length - assume arcs are straight lines)
length = [hypot(nodes['X'][arcs['Node1'][a]] - nodes['X'][arcs['Node2'][a]], nodes['Y'][arcs[
    'Node1'][a]] - nodes['Y'][arcs['Node2'][a]]) for a in A]

# Comm 3 - Base capacity for all restricted transmission lines [change for your data]
l = 83

# Comm 3 - Unrestricted transmission lines [change for your data]
Unrestricted = [66, 67, 68, 69, 92, 93, 104, 105, 108, 109, 138, 139, 142, 143, 144, 145, 158, 159]

# Comm 4 - Time periods (0 ==> 12am to 4am, 1==> 4am to 8am, etc.)
T = range(6)

# Comm 4 - Demand of node n during time period t
D = [[nodes['D' + str(t)][n] for t in T] for n in N]

# Comm 4 - Duration (in hours) of a time period
timePeriodDuration = 4

# Comm 6 - Restricted transmission lines
Restricted = [a for a in A if a not in Unrestricted]

# Comm 6 - Number of restricted transmission lines with increased capacity
numIncreasedArcLimit = 3

# Comm 6 - Amount of power to increase the capacity of the numIncreasedArcLimit restricted
# transmission lines by
arcCapacityIncrease = 50

# Comm 7 - gas generator data
numGasGenerators = 1
gasGeneratorCost = 77  # [change for your data]
gasGeneratorCapacity = 200

# Comm 8 - cannot build the gas generator at this node
bannedNode = 3

# Comm 8 - all nodes that the gas generator cannot be built at
MainGeneratorsAndBannedNode = mainGenerators + [bannedNode]

# Comm 9 - number of time periods per day that the gas generator can run in
gasGeneratorNumTimePeriods = 4

# Comm 10 - Solar farm data
numSolarFarms = 1
solarFarmCost = 42
solarFarmCapacities = [0, 20, 120, 110, 20, 0]

# Comm 11 - Percentage of capacity in which a main generator is running efficiently
efficientCapacityScale = 0.6

# Comm 11 - Scale factor to increase main generator cost by when producing more than
# 100(efficientCapacityScale)% of its capacity
costScale = 0.3

# Comm 12 - Scale factor of reduced demand
demandScale = 0.1

# Comm 12 - Maximum number of time periods in which customers will strive reduce their demand, at
# any given node
numDemandReduceTime = 1

# Comm 12 - Maximum number of nodes in which customers will strive reduce their demand, during any
# given time period
numDemandReduceNode = 9

# Create a Gurobi Model
m = Model("Electrigrid")

# Ensure no optimality gap
m.setParam('MIPGap', 0)

# Variables

# Power in arc a at the beginning of time period t
X = {(a, t): m.addVar() for a in A for t in T}

# Power generated efficiently (i.e. up to 100(efficientCapacityScale)% of the capacity), by main
# generator at node n in time period t
Y = {(n, t): m.addVar() for n in N for t in T}

# Power generated by gas generator at node n in time period t
G = {(n, t): m.addVar() for n in N for t in T}

# Power generated by solar farm at node n in time period t
S = {(n, t): m.addVar() for n in N for t in T}

# Power generated inefficiently (i.e. above 100(efficientCapacityScale)% of the capacity), by main
# generator at node n in time period t
Z = {(n, t): m.addVar() for n in N for t in T}

# 1 if the capacity of restricted arc a (i.e. l) should be increased by arcCapacityIncrease,
# 0 otherwise
P = {a: m.addVar(vtype=GRB.BINARY) for a in Restricted}

# 1 if building the gas generator at node n, 0 otherwise
K = {n: m.addVar(vtype=GRB.BINARY) for n in N}

# 1 if the gas generator should be running during time period t, 0 otherwise
O = {t: m.addVar(vtype=GRB.BINARY) for t in T}

# 1 if building the solar farm at node n, 0 otherwise
J = {n: m.addVar(vtype=GRB.BINARY) for n in N}

# 1 if demand at node n during time period t is reduced by demandScale, 0 otherwise
E = {(n, t): m.addVar(vtype=GRB.BINARY) for n in N for t in T}

# Objective
m.setObjective(timePeriodDuration *
               quicksum((quicksum(cost[n] * Y[n, t] + (1 + costScale) * cost[n] * Z[n, t] for n
                                  in mainGenerators) +
                         quicksum(gasGeneratorCost * G[n, t] for n in N if n not in
                                  mainGenerators) +
                         quicksum(solarFarmCost * S[n, t] for n in N))
                        for t in T
                        )
               )

# Constraints

# Constraint 1 - Ensure the power (efficiently) generated by a main generator is bounded by
# 100(efficientCapacityScale)% of its capacity
m.addConstrs(Y[n, t] <= efficientCapacityScale * c[n] for n in mainGenerators for t in T)

# Constraint 2 - Ensure the total power generated by a main generator is bounded by its capacity
m.addConstrs(Y[n, t] + Z[n, t] <= c[n] for n in mainGenerators for t in T)

# Constraints 3-4 - Ensure substation nodes cannot produce power from a main generator (i.e. main
# generators only exist at the main generator nodes)
m.addConstrs(Y[n, t] == 0 for n in N if n not in mainGenerators for t in T)
m.addConstrs(Z[n, t] == 0 for n in N if n not in mainGenerators for t in T)

# Constraint 5 - Ensure to balance the power flow across each node, taking into account powerLoss on
# inflow arcs, the power generated at each node (from the main generators, the gas generator, and
# the solar farm), and the (potentially reduced) demand of each node
m.addConstrs(quicksum(X[a, t] * (1 - powerLoss * length[a]) for a in A if arcs['Node2'][a] == n)
             + Y[n, t] + G[n, t] + S[n, t] + Z[n, t] == D[n][t] - demandScale * D[n][t] * E[n, t] +
             quicksum(X[a, t] for a in A if arcs['Node1'][a] == n) for n in N for t in T)

# Constraint 6 - Ensure all restricted arcs are bounded by their limit l
# (or l + arcCapacityIncrease if deemed optimal)
m.addConstrs(X[a, t] <= l + arcCapacityIncrease * P[a] for a in Restricted for t in T)

# Constraint 7 - Ensure exactly numIncreasedArcLimit (=3) arcs are increased in capacity
m.addConstr(quicksum(P[a] for a in Restricted) == numIncreasedArcLimit)

# Constraint 8 - Ensure the gas generator is bounded by its capacity. All other nodes must not have
# a gas generator, so should produce 0 MW 'from the gas generator'.
m.addConstrs(G[n, t] <= gasGeneratorCapacity * K[n] for n in N if n not in
             MainGeneratorsAndBannedNode for t in T)

# Constraint 9 - Ensure the gas generator cannot be built at the main generator nodes, nor the
# banned node
m.addConstrs(G[n, t] == 0 for n in MainGeneratorsAndBannedNode for t in T)

# Constraint 10 - Ensure exactly numGasGenerators (=1) generators are built
m.addConstr(quicksum(K[n] for n in N) == numGasGenerators)

# Constraint 11 - Ensure the gas generator is only running at the optimal time periods
m.addConstrs(G[n, t] <= gasGeneratorCapacity * O[t] for n in N if n not in
             MainGeneratorsAndBannedNode for t in T)

# Constraint 12 - Ensure the gas generator is running at exactly gasGeneratorNumTimePeriods (=4)
# time periods of the day
m.addConstr(quicksum(O[t] for t in T) == gasGeneratorNumTimePeriods)

# Constraint 13 - Ensure the solar farm is bounded by its capacity within any given time period.
# All other nodes must not have a solar farm, so should produce 0 MW 'from the solar farm'.
m.addConstrs(S[n, t] <= solarFarmCapacities[t] * J[n] for n in N for t in T)

# Constraint 14 - Ensure exactly numSolarFarms (=1) solar farms are built
m.addConstr(quicksum(J[n] for n in N) == numSolarFarms)

# Constraint 15 - Ensure that nodes reduces their demand during at most demandReduceTime (=1)
# time periods
m.addConstrs(quicksum(E[n, t] for t in T) <= numDemandReduceTime for n in N)

# Constraint 16 - Ensure that at most demandReduceNode (=9) nodes have a reduced demand during any
# given time period
m.addConstrs(quicksum(E[n, t] for n in N) <= numDemandReduceNode for t in T)

m.optimize()

# Round optimal cost to 2 d.p. (for cents...moreso for the report)
print("\nMinimum cost = $" + str(round(m.objVal, 2)))
print("Transmission lines to upgrade:", [r for r in Restricted if P[r].x == 1])
print("Node of gas generator:", [n for n in N if K[n].x == 1])
print("Optimal time periods for gas generator to run:", [t for t in T if O[t].x == 1])
print("Node of solar farm:", [n for n in N if J[n].x == 1])

print("\n\nMain Generator Production Values (MW/hr):")
[print(f"\t- Time period {t}:", [round(Y[n, t].x + Z[n, t].x, 2) for n in mainGenerators]) for t in
 T]

print("\nGas Generator Production Values (MW/hr):")
[print(f"\t- Time period {t}:", [round(G[n, t].x, 2) for n in N if K[n].x == 1]) for t in T]

print("\nSolar Farm Production Values (MW/hr):")
[print(f"\t- Time period {t}:", [round(S[n, t].x, 2) for n in N if J[n].x == 1]) for t in T]

print("\nNodes where Customers Reduced Demand:")
[print(f"\t- Time period {t}:", [round(n) for n in N if E[n, t].x == 1]) for t in T]
